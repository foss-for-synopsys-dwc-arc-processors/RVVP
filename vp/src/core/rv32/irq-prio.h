#pragma once

#include <array>
#include "trap-codes.h"
#include "irq-helpers.h"


namespace rv32 {

struct MajorOrderHolder {
	static constexpr uint32_t MAX_INTERRUPTS_NUM = 64;

	static constexpr uint8_t ORDER_MIN = 63;
	static constexpr uint8_t ORDER_MAX = 0;

	static constexpr std::array<uint8_t, MAX_INTERRUPTS_NUM> create_order()
	{
		std::array<uint8_t, MAX_INTERRUPTS_NUM> order = {};

		// NOTE: autogenerated, modify with a caution
		order[47]                                  = 0;
		order[EXC_BUS_SYSTEM_ERROR_INTERRUPT]      = 1;
		order[46]                                  = 2;
		order[EXC_HP_OT_EVENT_INTERRUPT]           = 3;
		order[22]                                  = 4;
		order[44]                                  = 5;
		order[EXC_HIGH_PRIO_RAS_INTERRUPT]         = 6;
		order[21]                                  = 7;
		order[42]                                  = 8;
		order[41]                                  = 9;
		order[20]                                  = 10;
		order[40]                                  = 11;
		order[EXC_M_EXTERNAL_INTERRUPT]            = 12;
		order[EXC_M_SOFTWARE_INTERRUPT]            = 13;
		order[EXC_M_TIMER_INTERRUPT]               = 14;
		order[EXC_S_EXTERNAL_INTERRUPT]            = 15;
		order[EXC_S_SOFTWARE_INTERRUPT]            = 16;
		order[EXC_S_TIMER_INTERRUPT]               = 17;
		order[EXC_S_GUEST_EXTERNAL_INTERRUPT]      = 18;
		order[EXC_VS_EXTERNAL_INTERRUPT]           = 19;
		order[EXC_VS_SOFTWARE_INTERRUPT]           = 20;
		order[EXC_VS_TIMER_INTERRUPT]              = 21;
		order[EXC_COUNTER_OVREFLOW_INTERRUPT]      = 22;
		order[39]                                  = 23;
		order[19]                                  = 24;
		order[38]                                  = 25;
		order[37]                                  = 26;
		order[18]                                  = 27;
		order[36]                                  = 28;
		order[EXC_LOW_PRIO_RAS_INTERRUPT]          = 29;
		order[EXC_DEBUG_TRACE_INTERRUPT]           = 30;
		order[34]                                  = 31;
		order[33]                                  = 32;
		order[16]                                  = 33;
		order[32]                                  = 34;
		// platform specific - treat all custom use interrupts (4â€“31 and 48 and higher) as a low priority ones
		order[24]                                  = 35;
		order[25]                                  = 36;
		order[26]                                  = 37;
		order[27]                                  = 38;
		order[28]                                  = 39;
		order[29]                                  = 40;
		order[30]                                  = 41;
		order[31]                                  = 42;
		order[EXC_WDT_INTERRUPT]                   = 43;
		order[49]                                  = 44;
		order[50]                                  = 45;
		order[51]                                  = 46;
		order[52]                                  = 47;
		order[53]                                  = 48;
		order[54]                                  = 49;
		order[55]                                  = 50;
		order[56]                                  = 51;
		order[57]                                  = 52;
		order[58]                                  = 53;
		order[59]                                  = 54;
		order[60]                                  = 55;
		order[61]                                  = 56;
		order[62]                                  = 57;
		order[63]                                  = 58;
		// unallocated from Privileged Architecture and unassigned in AIA
		order[0]                                   = 59;
		order[4]                                   = 60;
		order[8]                                   = 61;
		order[14]                                  = 62;
		order[15]                                  = 63;

		return order;
	}
};

struct major_irq : MajorOrderHolder {
	enum dpo { DPO_0_HIGHER_THAN_EXT = 0, DPO_1_LOWER_THAN_EXT = 1 };

	static uint8_t to_order(uint32_t iid) {
		assert(iid < MAX_INTERRUPTS_NUM);

		return order[iid];
	}

	// 0 = interrupt has higher default priority than an EI
	// 1 = interrupt has lower default priority than an EI
	static enum dpo get_dpo(PrivilegeLevel target_level, uint32_t iid) {
		assert(is_valid(iid));

		uint32_t target_level_external_irq = get_external_iid(target_level);
		uint32_t external_irq_order = to_order(target_level_external_irq);
		uint32_t lookup_irq_order = to_order(iid);

		if (lookup_irq_order < external_irq_order)
			return DPO_0_HIGHER_THAN_EXT;
		else if (lookup_irq_order == external_irq_order)
			assert(false);
		else
			return DPO_1_LOWER_THAN_EXT;
	}

	static bool is_valid(uint32_t iid) {
		return iid < MAX_INTERRUPTS_NUM;
	}

	static bool is_upper_bound_valid(uint32_t iid) {
		return iid < MAX_INTERRUPTS_NUM;
	}

	static bool is_external_iid(uint32_t iid) {
		return  iid == EXC_M_EXTERNAL_INTERRUPT ||
			iid == EXC_S_EXTERNAL_INTERRUPT ||
			iid == EXC_VS_EXTERNAL_INTERRUPT;
	}

	static uint32_t get_external_iid(PrivilegeLevel target_level) {
		switch (target_level) {
			case MachineMode:
				return EXC_M_EXTERNAL_INTERRUPT;
			case SupervisorMode:
				return EXC_S_EXTERNAL_INTERRUPT;
			case VirtualSupervisorMode:
				return EXC_VS_EXTERNAL_INTERRUPT;
			default:
				assert(false);
		}
	}

	static uint32_t transform_vs_to_s(uint32_t vs_iid) {
		assert(is_valid(vs_iid));

		// 12 - 63 - 1:1 mapping
		// 0  - 11 - VS standard irqs are shifted to S places. Other irqs are not supported
		if (vs_iid == EXC_VS_EXTERNAL_INTERRUPT)
			return EXC_S_EXTERNAL_INTERRUPT;
		else if (vs_iid == EXC_VS_TIMER_INTERRUPT)
			return EXC_S_TIMER_INTERRUPT;
		else if (vs_iid == EXC_VS_SOFTWARE_INTERRUPT)
			return EXC_S_SOFTWARE_INTERRUPT;
		else if (vs_iid > EXC_M_EXTERNAL_INTERRUPT)
			return vs_iid;
		else
			assert(false);
	}

	// bool : tranformable, uint32_t : iid
	static std::tuple<bool, uint32_t> transform_s_to_vs(uint32_t s_iid) {
		assert(is_valid(s_iid));

		// 12 - 63 - 1:1 mapping
		// 0  - 11 - VS standard irqs are shifted to S places. Other irqs are not supported
		if (s_iid == EXC_S_EXTERNAL_INTERRUPT)
			return {true, EXC_VS_EXTERNAL_INTERRUPT};
		else if (s_iid == EXC_S_TIMER_INTERRUPT)
			return {true, EXC_VS_TIMER_INTERRUPT};
		else if (s_iid == EXC_S_SOFTWARE_INTERRUPT)
			return {true, EXC_VS_SOFTWARE_INTERRUPT};
		else if (s_iid > EXC_M_EXTERNAL_INTERRUPT)
			return {true, s_iid};
		else
			return {false, 0};
	}

	static constexpr std::array<uint8_t, MAX_INTERRUPTS_NUM> order = create_order();
};


// cprio - comparable priority
struct irq_cprio {
	enum non_irq_cprio { LOWEST_NONEXISTING_CPRIO = 1 };

	irq_cprio(enum non_irq_cprio opt) {
		if (opt == LOWEST_NONEXISTING_CPRIO) {
			cprio = 0;
			fields.lowest_nonexisting = 1;
		}
	}
	// external irq
	irq_cprio(PrivilegeLevel level, uint32_t eiid) {
		assert(is_irq_capable_level(level));
		// constructing cprio from external irq with eiid = 0 is also an error
		// assert(is_valid_minor_iid(eiid));

		// when we inject interrupts with virt registers we can have
		// S [VS?] external irq pending when topei = 0
		// FIXME: just use priority = 0 for now. TODO: dpo?
		assert(is_upper_bound_valid_minor_iid(eiid));
		cprio = 0;
		fields.iprio = eiid;
		fields.order = major_irq::to_order(major_irq::get_external_iid(level));
	}
	// local irq
	irq_cprio(PrivilegeLevel level, uint32_t iid, uint8_t iprio) {
		assert(is_irq_capable_level(level));
		cprio = 0;
		// NOTE: for VS level we have iprio available on S interrupt places (so we have to itrerate with S major interrupt numbers)
		fields.iprio = iprio;
		fields.order = major_irq::to_order(iid);

		if (fields.iprio == 0) {
			fields.dpr_0 = major_irq::get_dpo(level, iid);
		}
	}
	// local hvictl-injected irq
	irq_cprio(PrivilegeLevel level, uint32_t iid, uint8_t iprio, bool dpr) {
		assert(is_irq_capable_level(level));
		cprio = 0;
		// NOTE: for VS level we have iprio available on S interrupt places (so we have to itrerate with S major interrupt numbers)
		fields.iprio = iprio;
		// hvictl-injected irq can be compared only to VS external irq, so we set
		// order to MIN/MAX depending on dpr
		fields.order = dpr ? major_irq::ORDER_MIN : major_irq::ORDER_MAX;
	}

	uint8_t to_iprio(void) const {
		assert(!is_non_existing());

		if (fields.iprio >= 1 && fields.iprio <= 255) {
			return fields.iprio;
		} else if (fields.iprio > 255) {
			return 255;
		} else if (fields.iprio == 0) {
			if (fields.dpr_0 == major_irq::DPO_0_HIGHER_THAN_EXT) {
				return 0;
			} else {
				return 255;
			}
		}

		assert(false);
	}

	bool is_non_existing(void) const {
		return fields.lowest_nonexisting != 0;
	}

	bool operator<(const irq_cprio& other) const {
		return this->cprio < other.cprio;
	}

	bool operator==(const irq_cprio& other) const {
		return this->cprio == other.cprio;
	}

private:
	union {
		uint32_t cprio = 0;
		// most significant component - Default Priority Rank, set if iprio == 0
		// less significant component - default order
		struct {
			unsigned order : 8;
			unsigned iprio : 16;
			unsigned dpr_0 : 1;
			unsigned lowest_nonexisting : 1;
			unsigned wpri0 : 6;
		} fields;
	};
};

}
